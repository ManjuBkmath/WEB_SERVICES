package com.danielpm1982.SOAP_WS1;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MavenWebSpringNoXmlSoapWsApplication {
	public static void main(String[] args) {
		SpringApplication.run(MavenWebSpringNoXmlSoapWsApplication.class, args);
	}
}

/*
This SOAP_WS1 project is a one server-side implementation for a SOAP webService PROVIDER 
that will be used/requested by another server-side implementation of a SOAP webService CONSUMER at another 
project - SOAP_WS1_Client. The provider will be deployed at the same localhost as the
consumer, but on different ports (8080 and 8181), so they can run in parallel in order to one to access
the other. The consumer server, for its part, will be accessed by a physical user, through http requests to
its Controllers, and the responses to the user will be returned through html from the view JSPs, as usual. 

When the user makes a request to the consumer server, this request will have its parameter data values bound 
to the Controller objects and manipulated through the Stubs of the consumer server (created from the
WSDL at the consumer server). Then, an XML request will be generated in order to be passed as request to 
the  other server (provider). The XML envelope, with the data on its body, travels over http between both servers. 
When it arrives at the provider server, the data from the XML is bound to the objects and stubs of the provider 
server, according to the WSDL at the provider server, and manipulated. Then, an output response is produced and 
sent back from the provider to the consumer, also via xml over http. The consumer binds the XML response data 
to java objects at the Controller, then to html and, at last, returns the answer to the user, showing some 
response on the screen (notebook, smartphone, smartv, tablets, smartwatch, etc).

The contract for the stub object classes and the generated XML between the two servers are the WSDLs (xsd files), 
one at each server. The first WSDL (at the provider) is manually created, the second one (at the consumer)
is based on the first one and is automatically created by the Apache CXF API maven plugin, as the stubs. The
second WSDL takes into account the concrete PortType implemented manually by the programming, that will be
accessed by the consumer.

JAX-WS and JAXB APIs are used by the Apache CXF API maven plugin at both servers to generate and annotate the
stub classes accordingly, using the WSDLs.

In a top-bottom development process (WSDL first), usually used for new projects as this one, first the provider 
server is implemented and deployed, then the consumer server is created.

Considering the provider server implementation here (SOAP_WS1), firstly a new SpringBoot 
project has been created and minimally configured. Secondly, a WSDL file has been manually created with all the 
structures needed for the XML messages and for all stub java objects later generated. The WSDL is an xsd file 
that comprises basically the types, elements, messages, portType and service data, used by that server and xml APIs. 
Thirdly, a plugin of Apache CXF has been added to the maven POM of the project, which automatically generated 
the stubs. Still on the provider-server side, the portType stub interface has been implemented with the logics 
needed for processing future requests from the consumer. And lastly, finishing the provider server implementation, 
an EndPoint for that webService access has been defined and published using a config class. A simple and optional 
Controller/View user interface has also been created for testing purposes, although not needed to provide any of 
the services to the consumer server.

Considering now the consumer server implementation, its WSDL is not the same abstract WSDL used at the provider, 
but a similar one, generated by the CXF, and added manually to the consumer server project, which maps to the 
service and portType data of the provider server implemented by the programmer. The CXF plugin is equally added 
to the consumer server project POM, and the consumer stubs are automatically generated, according to the WSDL at 
the consumer project. The use of these service and portType, thus, makes it possible for the consumer to use the 
provider webServices and have the responses returned and shown to the final user.

The business logics of both server projects are pretty simple and deals basically with Orders of Products by 
Customers, having as portType operations getOrders and createOrders, with input and output parameters. 
CreateCustomer operation has not been implemented, and only a sample and single client is generated 
at the Constructor of the portType implementation class (provider server project). Orders are modeled as
lists of orders, each order composed of lists of products, and managed by a map of clientId/OrderList 
which simulates a DB, also not implemented here.

These two projects are solely intended to showing the basic architecture and implementation of SOAP webServices, 
and of the Provider/Consumer servers, using SpringBoot, Apache CXF, JAX-WS and JAXB, having a customized and manually 
created WSDL (xsd) as a contract for the XML messages and for the stubs generation on each side.

For running these 2 SOAP webServices apps, run both main SpringBoot classes of each project as a java Application, 
then use a browser, on any device, to test it using the same network and local ip. Sample operation requests have 
been set at the html links of each project web UI, others can be tested using SoapUI, for instance. At the consumer 
side, a console testing class has also been created, independent from the web view UI.

For more information see:
https://www.ibm.com/developerworks/library/ws-whichwsdl/index.html
https://cxf.apache.org/
https://spring.io/projects/spring-boot
*/
